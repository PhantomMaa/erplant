package io.erplant.converter

import com.squareup.javapoet.*
import io.erplant.*
import io.erplant.utils.HumpUtil
import javax.lang.model.element.Modifier
import kotlin.math.abs


class DaoTestConverter(packageName: String, val render: BaseRender, tableConfigMap: Map<String, TableConfig>, private val jdkVersion: Int) :
    JavaPoetConverter(packageName, tableConfigMap) {

    override fun getSupportType(): SupportType {
        return SupportType.DaoTest
    }

    override fun convertTable(databaseName: String, table: Table): FileContent {
        val fileName = super.getOutFileName(table.doName)
        val tableInfo = TableInfo(packageName, databaseName, table, render)
        val methods = genMethods(table, tableInfo)

        val fullPackageName = tableInfo.getDaoTestClass().packageName()
        val className = tableInfo.daoTestClassName
        val fields = genFields(table, tableInfo)
        val annotations = genAnnotations(databaseName)
        val javaDocAuthor = "auto generated by erplant."
        val typeSpec = TypeSpec.classBuilder(className)
            .addJavadoc(javaDocAuthor)
            .addAnnotations(annotations)
            .addModifiers(Modifier.PUBLIC)
            .addFields(fields)
            .addMethods(methods)
            .build()
        val javaFile = JavaFile.builder(fullPackageName, typeSpec)
            .indent(StrConstant.INDENT)
            .build()
        return FileContent(fileName, javaFile.toString())
    }

    private fun genMethods(table: Table, tableInfo: TableInfo): List<MethodSpec> {
        val methods = mutableListOf(
            genInsert(table, tableInfo),
            genGet(table, tableInfo),
            genGetByBk(table, tableInfo),
            genPageNumQuery(table, tableInfo),
            genOffsetQuery(table, tableInfo),
            genCount(table, tableInfo),
            genUpdate(table, tableInfo),
            genDelete(table, tableInfo)
        )

        val supportBatchGet = super.isSupportBatchGet(table)
        if (supportBatchGet) {
            methods.add(genBatchGet(table, tableInfo))
        }

        val methodGetByUks =
            table.indexes?.filter { it.indexType == IndexType.Unique }?.map { genGetByUk(tableInfo, it) } ?: emptyList()
        methods.addAll(methodGetByUks)

        return methods.filterNotNull()
    }

    private fun genAnnotations(databaseName: String): List<AnnotationSpec> {
        val applicationClassName = HumpUtil.lineToHump("${databaseName}_application", true)
        val applicationClass = ClassName.get("$packageName.$databaseName", applicationClassName)
        val springAnnotation = ClassName.get("org.springframework.boot.test.context", "SpringBootTest")
        val springAnnotationSpec = AnnotationSpec.builder(springAnnotation)
            .addMember("classes", "\$T.class", applicationClass)
            .build()

        val testOrderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "TestMethodOrder")
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "MethodOrderer")
        val testOrderAnnotationSpec = AnnotationSpec.builder(testOrderAnnotation)
            .addMember("value", "\$T.OrderAnnotation.class", orderAnnotation)
            .build()
        return listOf(springAnnotationSpec, testOrderAnnotationSpec)
    }

    private fun genFields(table: Table, tableInfo: TableInfo): List<FieldSpec> {
        val jakartaPackage = StrConstant.getJakartaPackage(jdkVersion)
        val daoClass = ClassName.get(tableInfo.getDaoClass().packageName(), tableInfo.getDaoClass().simpleName())
        val daoClassField = FieldSpec.builder(daoClass, tableInfo.daoInstanceName)
            .addModifiers(Modifier.PRIVATE)
            .addAnnotation(ClassName.get(jakartaPackage, "Resource"))
            .build()

        val fieldList = mutableListOf(daoClassField)
        val skipUpdateColumnNames = SkipUpdateColumn.values().map { it.name.lowercase() }.toSet()
        val queryColumns = table.columns
            .filter { !skipUpdateColumnNames.contains(it.columnName) }
            .filter { it.columnType == ColumnType.UniqueKey || it.columnType == ColumnType.Index }
        val queryFields = queryColumns.map {
            val fieldType = super.convertToFieldType(it)
            val fieldClass = ClassName.get("", fieldType)
            val fieldName = HumpUtil.lineToHump(it.columnName, false)
            val randomValue = randomValue(fieldType, fieldName)
            FieldSpec.builder(fieldClass, fieldName)
                .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
                .initializer("\$L", randomValue)
                .build()
        }

        val bkIndex = table.indexes?.firstOrNull { it.indexType == IndexType.UniqueBK }
        if (bkIndex == null) {
            // 如果没有业务主键，就生成一个id字段来承接insert之后的id返回值
            val idField = FieldSpec.builder(ClassName.get("", "Long"), "id")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
                .build()
            fieldList.add(idField)
        }

        fieldList.addAll(queryFields)
        return fieldList
    }

    private fun genInsert(table: Table, tableInfo: TableInfo): MethodSpec {
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "1").build()
        val methodBuilder = MethodSpec.methodBuilder("testInsert")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        methodBuilder.addStatement(
            "\$T ${tableInfo.doInstanceName} = new \$T()",
            tableInfo.getDoClass(),
            tableInfo.getDoClass()
        )

        val setDoCodes = genSetDoFields(table, tableInfo)
        setDoCodes.forEach { methodBuilder.addStatement(it) }
        methodBuilder.addStatement("int affectRow = ${tableInfo.daoInstanceName}.insert(${tableInfo.doInstanceName})")
            .addStatement("\$T.assertTrue(affectRow > 0)", ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions"))

        val bkIndex = table.indexes?.firstOrNull { it.indexType == IndexType.UniqueBK }
        if (bkIndex == null) {
            // 如果没有业务主键，就生成一个id字段来承接insert之后的id返回值
            methodBuilder.addStatement("id = ${tableInfo.doInstanceName}.getId()")
        }

        return methodBuilder.build()
    }

    private fun genDelete(table: Table, tableInfo: TableInfo): MethodSpec {
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "4").build()
        val methodBuilder = MethodSpec.methodBuilder("testDelete")
        methodBuilder.addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val getStatement = genGetStatement(table, tableInfo)
        if (getStatement != null) {
            methodBuilder.addStatement(getStatement)
        }

        val bigPkFieldName = HumpUtil.lineToHump(table.getPrimaryColumn().columnName, true)
        return methodBuilder.addStatement("int affectRow = ${tableInfo.daoInstanceName}.delete(${tableInfo.doInstanceName}.get${bigPkFieldName}())")
            .addStatement("\$T.assertTrue(affectRow > 0)", ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions"))
            .build()
    }

    private fun genGetStatement(table: Table, tableInfo: TableInfo): CodeBlock? {
        val bkIndex = table.indexes?.firstOrNull { it.indexType == IndexType.UniqueBK }
        return if (bkIndex == null) {
            CodeBlock.of(
                "\$T ${tableInfo.doInstanceName} = ${tableInfo.daoInstanceName}.get(id)",
                tableInfo.getDoClass()
            )
        } else {
            val bkFields = getBkFields(table, bkIndex)
            CodeBlock.of(
                "\$T ${tableInfo.doInstanceName} = ${tableInfo.daoInstanceName}.getByBk(new \$T($bkFields))",
                tableInfo.getDoClass(), tableInfo.getBkClass()
            )
        }
    }

    private fun genGet(table: Table, tableInfo: TableInfo): MethodSpec {
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "2").build()
        val methodBuilder = MethodSpec.methodBuilder("testGet")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val getStatement = genGetStatement(table, tableInfo)
        if (getStatement != null) {
            methodBuilder.addStatement(getStatement)
        }

        return methodBuilder.addStatement(
            "\$T.assertNotNull(${tableInfo.doInstanceName})",
            ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions")
        ).build()
    }

    private fun genBatchGet(table: Table, tableInfo: TableInfo): MethodSpec {
        val list = ClassName.get("java.util", "List")
        val typedDoClass: TypeName = ParameterizedTypeName.get(list, tableInfo.getDoClass())
        val immutableList = ClassName.get("java.util", "List")
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "2").build()
        val methodBuilder = MethodSpec.methodBuilder("testBatchGet")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val getStatement = genGetStatement(table, tableInfo)
        if (getStatement != null) {
            methodBuilder.addStatement(getStatement)
        }

        val bigPkFieldName = HumpUtil.lineToHump(table.getPrimaryColumn().columnName, true)
        return methodBuilder
            .addStatement(
                "\$T list = ${tableInfo.daoInstanceName}.batchGet(\$T.of(${tableInfo.doInstanceName}.get${bigPkFieldName}()))",
                typedDoClass, immutableList
            ).addStatement(
                "\$T.assertFalse(list.isEmpty())",
                ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions")
            ).build()
    }

    private fun genPageNumQuery(table: Table, tableInfo: TableInfo): MethodSpec? {
        if (!table.needGenPageNumQuery()) {
            return null
        }

        val list = ClassName.get("java.util", "List")
        val typedDoClass: TypeName = ParameterizedTypeName.get(list, tableInfo.getDoClass())
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "2").build()
        val methodBuilder = MethodSpec.methodBuilder("testPageNumQuery")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val queryBuildCode = genQueryBuildCode(table)
        methodBuilder.addStatement(queryBuildCode, tableInfo.getPageNumQueryClass(), tableInfo.getPageNumQueryClass())
        return methodBuilder
            .addStatement("\$T list = ${tableInfo.daoInstanceName}.pageNumQuery(query)", typedDoClass)
            .addStatement(
                "\$T.assertFalse(list.isEmpty())",
                ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions")
            )
            .build()
    }

    private fun genOffsetQuery(table: Table, tableInfo: TableInfo): MethodSpec? {
        if (!table.needGenOffsetQuery()) {
            return null
        }

        val list = ClassName.get("java.util", "List")
        val typedDoClass: TypeName = ParameterizedTypeName.get(list, tableInfo.getDoClass())
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "2").build()
        val methodBuilder = MethodSpec.methodBuilder("testOffsetQuery")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val queryBuildCode = genQueryBuildCode(table)
        methodBuilder.addStatement(queryBuildCode, tableInfo.getOffsetQueryClass(), tableInfo.getOffsetQueryClass())
        return methodBuilder
            .addStatement("\$T list = ${tableInfo.daoInstanceName}.offsetQuery(query)", typedDoClass)
            .addStatement(
                "\$T.assertFalse(list.isEmpty())",
                ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions")
            )
            .build()
    }

    private fun genCount(table: Table, tableInfo: TableInfo): MethodSpec? {
        if (!table.needGenPageNumQuery()) {
            return null
        }

        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "2").build()
        val methodBuilder = MethodSpec.methodBuilder("testCount")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val queryBuildCode = genQueryBuildCode(table)
        methodBuilder.addStatement(queryBuildCode, tableInfo.getPageNumQueryClass(), tableInfo.getPageNumQueryClass())
        return methodBuilder
            .addStatement("int count = ${tableInfo.daoInstanceName}.count(query)")
            .addStatement("\$T.assertTrue(count > 0)", ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions"))
            .build()
    }

    private fun genUpdate(table: Table, tableInfo: TableInfo): MethodSpec {
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "3").build()
        val methodBuilder = MethodSpec.methodBuilder("testUpdate")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val getStatement = genGetStatement(table, tableInfo)
        if (getStatement != null) {
            methodBuilder.addStatement(getStatement)
        }

        val setDoCodes = genSetDoFields(table, tableInfo)
        setDoCodes.forEach { methodBuilder.addStatement(it) }

        return methodBuilder.addStatement("int affectRow = ${tableInfo.daoInstanceName}.update(${tableInfo.doInstanceName})")
            .addStatement("\$T.assertTrue(affectRow > 0)", ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions"))
            .build()
    }

    private fun genGetByBk(table: Table, tableInfo: TableInfo): MethodSpec? {
        table.indexes?.firstOrNull { it.indexType == IndexType.UniqueBK } ?: return null

        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "2").build()

        val methodBuilder = MethodSpec.methodBuilder("testGetByBk")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val getStatement = genGetStatement(table, tableInfo)
        if (getStatement != null) {
            methodBuilder.addStatement(getStatement)
        }

        return methodBuilder.addStatement(
            "\$T.assertNotNull(${tableInfo.doInstanceName})",
            ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions")
        ).build()
    }

    private fun genGetByUk(tableInfo: TableInfo, ukIndex: Index): MethodSpec {
        val orderAnnotation = ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Order")
        val orderAnnotationSpec = AnnotationSpec.builder(orderAnnotation).addMember("value", "2").build()

        val bigIndexName = HumpUtil.lineToHump(ukIndex.indexName.split("uk_")[1], true)
        val methodBuilder = MethodSpec.methodBuilder("testGetBy$bigIndexName")
            .addAnnotation(ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Test"))
            .addAnnotation(orderAnnotationSpec)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.VOID)

        val paramNames = ukIndex.columns.map { HumpUtil.lineToHump(it.columnName, false) }
            .joinToString(separator = ", ") { it }

        return methodBuilder.addStatement(
            "\$T ${tableInfo.doInstanceName} = ${tableInfo.daoInstanceName}.getBy$bigIndexName($paramNames)",
            tableInfo.getDoClass()
        ).addStatement(
            "\$T.assertNotNull(${tableInfo.doInstanceName})",
            ClassName.get(StrConstant.STR_JUNIT5_PACKAGE, "Assertions")
        ).build()
    }

    private fun genSetDoFields(table: Table, tableInfo: TableInfo): List<String> {
        val ukColumns = table.columns.filter { it.columnType == ColumnType.UniqueKey }
        val ukFieldsCodes = ukColumns.map {
            val fieldName = HumpUtil.lineToHump(it.columnName, false)
            val bigFieldName = HumpUtil.lineToHump(it.columnName, true)
            "${tableInfo.doInstanceName}.set$bigFieldName($fieldName)"
        }

        val notnullColumns = table.columns.filter { it.notNull }
        val skipUpdateColumnNames = SkipUpdateColumn.values().map { it.name.lowercase() }.toSet()
        val ukColumnNames = ukColumns.map { it.columnName }
        val notnullFieldsCodes = notnullColumns
            .filter { !skipUpdateColumnNames.contains(it.columnName) }
            .filter { !ukColumnNames.contains(it.columnName) }
            .map {
                val bigFieldName = HumpUtil.lineToHump(it.columnName, true)
                val fieldType = super.convertToFieldType(it)
                val fieldName = HumpUtil.lineToHump(it.columnName, false)
                val randomValue = randomValue(fieldType, fieldName)
                "${tableInfo.doInstanceName}.set$bigFieldName($randomValue)"
            }

        val lines = mutableListOf<String>()
        lines.addAll(ukFieldsCodes)
        lines.addAll(notnullFieldsCodes)
        return lines
    }

    private fun genQueryBuildCode(table: Table): String {
        val queryCodes = table.getQueryColumns()!!.map {
            val field = columnToField(it)
            if (field.notNull) {
                val fieldName = field.fieldName
                ".$fieldName($fieldName)"
            } else {
                ""
            }
        }
        var queryBuild = "\$T query = \$T.builder()"
        queryCodes.forEach { queryBuild += it }
        queryBuild += ".build()"
        return queryBuild
    }

    private fun getBkFields(table: Table, bkIndex: Index): String {
        val bkFields = bkIndex.columns.map { HumpUtil.lineToHump(it.columnName, false) }
        val notnullColumns = table.columns.filter { it.notNull }
        val fieldValueMap = notnullColumns.filter { it.columnType == ColumnType.Normal }.associate {
            val fieldName = HumpUtil.lineToHump(it.columnName, false)
            val fieldType = super.convertToFieldType(it)
            val randomValue = randomValue(fieldType, fieldName)
            fieldName to randomValue
        }
        return bkFields.map { fieldValueMap[it] ?: it }.joinToString(separator = ", ") { it.toString() }
    }

    private fun randomValue(fieldType: String, fieldName: String): Any {
        val hashCode = abs(fieldName.hashCode())
        return when (fieldType) {
            "String" -> {
                val str = (hashCode % 1000).toString().toCharArray().map { it + 49 }.joinToString(separator = "")
                "\"$str\""
            }

            "int", "Integer" -> {
                hashCode % 10
            }

            "long" -> {
                hashCode % 100
            }

            "Long" -> {
                val value = hashCode % 100
                "${value}L"
            }

            "byte[]" -> {
                "\"hello\".getBytes()"
            }

            "LocalDateTime" -> {
                ClassName.get("java.time", "LocalDateTime.now()")
            }

            else -> {
                "unknow"
            }
        }
    }
}

