package io.erplant.converter

import com.squareup.javapoet.*
import io.erplant.*
import io.erplant.utils.HumpUtil
import javax.lang.model.element.Modifier

class EntityConverter(packageName: String, val render: BaseRender, tableConfigMap: Map<String, TableConfig>) :
    JavaPoetConverter(packageName, tableConfigMap) {

    override fun getSupportType(): SupportType {
        return SupportType.Entity
    }

    /**
     * 获得每个表对应的输出结果的文件名
     */
    override fun getOutFileName(tableName: String): String {
        return HumpUtil.lineToHump(tableName, true) + ".java"
    }

    override fun convertTable(databaseName: String, table: Table): FileContent {
        val fileName = getOutFileName(table.doName)
        val tableInfo = TableInfo(packageName, databaseName, table, render)
        val fields = genFields(table, tableInfo)
        val method = genGetBkMethod(table, tableInfo)
        val className = tableInfo.getEntityClass()
        val fullPackageName = className.packageName()

        val javaDocAuthor = "auto generated by erplant."
        val aggregateRootClass = ParameterizedTypeName.get(
            ClassName.get("com.hellocorp.automq.ddd", "AggregateRoot"),
            tableInfo.getBkClass()
        )
        val typeSpec = TypeSpec.classBuilder(className)
            .addJavadoc(javaDocAuthor)
            .addAnnotation(ClassName.get("lombok", "Data"))
            .addModifiers(Modifier.PUBLIC)
            .addSuperinterface(aggregateRootClass)
            .addFields(fields)
            .addMethod(method)
            .build()
        val javaFile = JavaFile.builder(fullPackageName, typeSpec).indent(StrConstant.INDENT).build()
        return FileContent(fileName, javaFile.toString())
    }

    private fun genFields(table: Table, tableInfo: TableInfo): List<FieldSpec> {
        val fields = mutableListOf<FieldSpec>()
        val setterAnnotation = AnnotationSpec.builder(ClassName.get("lombok", "Setter"))
            .addMember("value", "\$T.NONE", ClassName.get("lombok", "AccessLevel"))
            .build()
        val bkField = FieldSpec.builder(tableInfo.getBkClass(), "bk")
            .addModifiers(Modifier.PRIVATE)
            .addAnnotation(setterAnnotation)
            .build()
        fields.add(bkField)

        val columnFields = genColumnFields(table)
        fields.addAll(columnFields)

        // 将ExtensionVO里的属性平铺开
        val flattenExtensionFields = flattenExtensionFields(table)
        fields.addAll(flattenExtensionFields)

        return fields
    }

    private fun genColumnFields(table: Table): List<FieldSpec> {
        val extensionColumns = table.extensions?.groupBy { it.columnName }?.map { it.key } ?: emptyList()
        return table.columns
            .filter { !extensionColumns.contains(it.columnName) }
            .map { columnToFieldSpec(it) }
    }

    private fun flattenExtensionFields(table: Table): List<FieldSpec> {
        if (table.extensions == null) {
            return emptyList()
        }

        val columnAttributesMap = table.extensions.groupBy { it.columnName }
        return columnAttributesMap.map {
            val extensionFields = columnAttributesMap[it.key]?.map { extension ->
                ExtensionField(extension.fieldName, extension.fieldType, extension.comment)
            } ?: emptyList()
            super.genExtensionFields(extensionFields)
        }.flatten()
    }

    private fun genGetBkMethod(table: Table, tableInfo: TableInfo): MethodSpec {
        val fieldNames = table.getBkColumns()?.map { columnToField(it).fieldName } ?: emptyList()
        val fieldNamesStr = fieldNames.joinToString(separator = ", ")
        return MethodSpec.methodBuilder("getBk")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("return new \$T($fieldNamesStr)", tableInfo.getBkClass())
            .returns(ClassName.get("", tableInfo.bKClassName))
            .build()
    }
}
