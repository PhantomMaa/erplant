package io.erplant.converter

import com.squareup.javapoet.*
import io.erplant.*
import io.erplant.utils.HumpUtil
import javax.lang.model.element.Modifier

class DoConverter(packageName: String, val render: BaseRender, tableConfigMap: Map<String, TableConfig>) :
    JavaPoetConverter(packageName, tableConfigMap) {

    override fun getSupportType(): SupportType {
        return SupportType.DO
    }

    override fun convertTable(databaseName: String, table: Table): FileContent {
        val fileName = super.getOutFileName(table.doName)
        val tableInfo = TableInfo(packageName, databaseName, table, render)
        val fields = genFields(table)
        val methods = genExtensionMethods(table)
        val innerClasses = genInnerClass(table)

        val javaDocAuthor = "auto generated by erplant."
        val typeSpec = TypeSpec.classBuilder(tableInfo.doClassName)
            .addJavadoc(javaDocAuthor)
            .addAnnotation(ClassName.get("lombok", "Data"))
            .addModifiers(Modifier.PUBLIC)
            .addFields(fields)
            .addMethods(methods)
            .addTypes(innerClasses)
            .build()
        val javaFile = JavaFile.builder(tableInfo.getDoClass().packageName(), typeSpec)
            .indent(StrConstant.INDENT)
            .build()
        return FileContent(fileName, javaFile.toString())
    }

    private fun genFields(table: Table): List<FieldSpec> {
        return table.columns.map { columnToFieldSpec(it) }
    }

    private fun genExtensionMethods(table: Table): List<MethodSpec> {
        if (table.extensions == null) {
            return emptyList()
        }

        return table.extensions
            .map { it.columnName }
            .distinct()
            .map { listOf(genGetExtensionVO(it), genSetExtensionVO(it)) }
            .flatten()
    }

    private fun genGetExtensionVO(columnName: String): MethodSpec {
        val smallHumpName = HumpUtil.lineToHump(columnName, false)
        val bigHumpName = HumpUtil.lineToHump(columnName, true)
        return MethodSpec.methodBuilder("get${bigHumpName}VO")
            .addModifiers(Modifier.PUBLIC)
            .addStatement(
                "return \$T.toObj(${smallHumpName}, \$T.class)",
                ClassName.get("com.hellocorp.automq.ddd.util", "JacksonUtil"),
                ClassName.get("", "${bigHumpName}VO")
            )
            .returns(ClassName.get("", "${bigHumpName}VO"))
            .build()
    }

    private fun genSetExtensionVO(columnName: String): MethodSpec {
        val smallHumpName = HumpUtil.lineToHump(columnName, false)
        val bigHumpName = HumpUtil.lineToHump(columnName, true)
        val param = ParameterSpec.builder(ClassName.get("", "${bigHumpName}VO"), "${smallHumpName}VO").build()
        return MethodSpec.methodBuilder("set${bigHumpName}VO")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(param)
            .addStatement(
                "this.${smallHumpName} = \$T.toJsonString(${smallHumpName}VO)",
                ClassName.get("com.hellocorp.automq.ddd.util", "JacksonUtil")
            )
            .build()
    }

    private fun genInnerClass(table: Table): List<TypeSpec> {
        if (table.extensions == null) {
            return emptyList()
        }

        val columnAttributesMap = table.extensions.groupBy { it.columnName }
        return columnAttributesMap.map {
            val bigHumpName = HumpUtil.lineToHump(it.key, true)
            val extensionFields = columnAttributesMap[it.key]?.map { extension ->
                ExtensionField(extension.fieldName, extension.fieldType, extension.comment)
            } ?: emptyList()
            val fields = super.genExtensionFields(extensionFields)
            TypeSpec.classBuilder("${bigHumpName}VO")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addAnnotation(ClassName.get("lombok", "Data"))
                .addFields(fields)
                .build()
        }
    }
}
