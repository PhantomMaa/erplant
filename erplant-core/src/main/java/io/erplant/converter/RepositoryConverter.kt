package io.erplant.converter

import com.squareup.javapoet.*
import io.erplant.*
import io.erplant.utils.HumpUtil
import javax.lang.model.element.Modifier

class RepositoryConverter(packageName: String, val render: BaseRender, tableConfigMap: Map<String, TableConfig>, private val jdkVersion: Int) :
    JavaPoetConverter(packageName, tableConfigMap) {

    override fun getSupportType(): SupportType {
        return SupportType.Repository
    }

    private fun getQueryClass(table: Table, tableInfo: TableInfo): ClassName {
        return if (table.needGenPageNumQuery()) {
            tableInfo.getPageNumQueryClass()
        } else {
            ClassName.get("com.hellocorp.automq.ddd", "PageNumQuery")
        }
    }

    private fun getOffsetQueryClass(table: Table, tableInfo: TableInfo): ClassName {
        return if (table.needGenOffsetQuery()) {
            tableInfo.getOffsetQueryClass()
        } else {
            ClassName.get("com.hellocorp.automq.ddd", "OffsetQuery")
        }
    }

    override fun convertTable(databaseName: String, table: Table): FileContent {
        val fileName = super.getOutFileName(table.doName)
        val tableInfo = TableInfo(packageName, databaseName, table, render)
        val fields = genFields(tableInfo)
        val methods = genMethods(table, tableInfo)

        val className = tableInfo.getRepositoryClass()
        val fullPackageName = className.packageName()
        val javaDocAuthor = "auto generated by erplant."
        val aggregateRootClass = ParameterizedTypeName.get(
            ClassName.get("com.hellocorp.automq.ddd", "Repository"),
            tableInfo.getEntityClass(),
            getQueryClass(table, tableInfo),
            getOffsetQueryClass(table, tableInfo),
            tableInfo.getBkClass()
        )
        val typeSpec = TypeSpec.classBuilder(className)
            .addJavadoc(javaDocAuthor)
            .addAnnotation(ClassName.get("lombok.extern.slf4j", "Slf4j"))
            .addAnnotation(ClassName.get("org.springframework.stereotype", "Component"))
            .addModifiers(Modifier.PUBLIC)
            .addSuperinterface(aggregateRootClass)
            .addFields(fields)
            .addMethods(methods)
            .build()
        val javaFile = JavaFile.builder(fullPackageName, typeSpec)
            .indent(StrConstant.INDENT)
            .skipJavaLangImports(true)
            .build()
        return FileContent(fileName, javaFile.toString())
    }

    private fun genFields(tableInfo: TableInfo): List<FieldSpec> {
        val fields = mutableListOf<FieldSpec>()

        val jakartaPackage = StrConstant.getJakartaPackage(jdkVersion)
        val daoField = FieldSpec.builder(tableInfo.getDaoClass(), tableInfo.daoInstanceName)
            .addAnnotation(ClassName.get(jakartaPackage, "Resource"))
            .build()
        fields.add(daoField)

        val converterFieldAnnotation = AnnotationSpec.builder(ClassName.get(jakartaPackage, "Resource"))
            .addMember("name", "\$S", "${tableInfo.converterInstanceName}Impl")
            .build()
        val converterField = FieldSpec.builder(tableInfo.getConverterClass(), tableInfo.converterInstanceName)
            .addAnnotation(converterFieldAnnotation)
            .addModifiers(Modifier.PROTECTED)
            .build()
        fields.add(converterField)

        return fields
    }


    private fun genMethods(table: Table, tableInfo: TableInfo): List<MethodSpec> {
        val methods = mutableListOf(
            genGetDao(tableInfo),
            genGet(tableInfo),
            genGetByBk(table, tableInfo),
            genGetAndLockByBk(table, tableInfo),
            genBatchGet(table, tableInfo),
            genRemove(tableInfo),
            genRemoveByBk(tableInfo),
            genSave(table, tableInfo),
            genCreate(tableInfo),
            genUpdate(tableInfo),
            genPageNumQuery(table, tableInfo),
            genOffsetQuery(table, tableInfo),
            genCount(table, tableInfo)
        )

        val methodGetByUks = table.indexes
            ?.filter { it.indexType == IndexType.Unique }
            ?.map { genGetByUk(tableInfo, it) }
            ?: emptyList()
        methods.addAll(methodGetByUks)

        return methods.filterNotNull()
    }

    private fun genGetDao(tableInfo: TableInfo): MethodSpec {
        return MethodSpec.methodBuilder("get${tableInfo.daoClassName}")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("return ${tableInfo.daoInstanceName}", tableInfo.getDoClass())
            .returns(tableInfo.getDaoClass())
            .build()
    }

    private fun genGet(tableInfo: TableInfo): MethodSpec {
        return MethodSpec.methodBuilder("get")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(ParameterSpec.builder(TypeName.LONG.box(), "id").build())
            .addStatement(
                "\$T ${tableInfo.doInstanceName} = get${tableInfo.daoClassName}().get(id)",
                tableInfo.getDoClass()
            )
            .addStatement("return ${tableInfo.converterInstanceName}.to${tableInfo.entityClassName}(${tableInfo.doInstanceName})")
            .returns(tableInfo.getEntityClass())
            .build()
    }

    private fun genGetByBk(table: Table, tableInfo: TableInfo): MethodSpec {
        val methodBuilder = MethodSpec.methodBuilder("getByBk")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(ParameterSpec.builder(tableInfo.getBkClass(), "bk").build())

        val bkIndex = table.indexes?.firstOrNull { it.indexType == IndexType.UniqueBK }
        if (bkIndex == null) {
            methodBuilder.addStatement(
                "throw new \$T(\"this table type does not support getByBk\")",
                ClassName.get("", "UnsupportedOperationException")
            )
        } else {
            methodBuilder.addStatement(
                "\$T ${tableInfo.doInstanceName} = get${tableInfo.daoClassName}().getByBk(bk)",
                tableInfo.getDoClass()
            )
            methodBuilder.addStatement("return ${tableInfo.converterInstanceName}.to${tableInfo.entityClassName}(${tableInfo.doInstanceName})")
        }

        return methodBuilder.returns(tableInfo.getEntityClass()).build()
    }

    private fun genGetAndLockByBk(table: Table, tableInfo: TableInfo): MethodSpec {
        val methodBuilder = MethodSpec.methodBuilder("getAndLockByBk")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(ParameterSpec.builder(tableInfo.getBkClass(), "bk").build())

        val bkIndex = table.indexes?.firstOrNull { it.indexType == IndexType.UniqueBK }
        if (bkIndex == null) {
            methodBuilder.addStatement(
                "throw new \$T(\"this table type does not support getAndLockByBk\")",
                ClassName.get("", "UnsupportedOperationException")
            )
        } else {
            methodBuilder.addStatement(
                "\$T ${tableInfo.doInstanceName} = get${tableInfo.daoClassName}().getAndLockByBk(bk)",
                tableInfo.getDoClass()
            )
            methodBuilder.addStatement("return ${tableInfo.converterInstanceName}.to${tableInfo.entityClassName}(${tableInfo.doInstanceName})")
        }

        return methodBuilder.returns(tableInfo.getEntityClass()).build()
    }

    private fun genGetByUk(tableInfo: TableInfo, ukIndex: Index): MethodSpec {
        val params = ukIndex.columns.map {
            val field = columnToField(it)
            val fieldClass = super.fieldTypeToJavaClass(field.fileType)
            ParameterSpec.builder(fieldClass, field.fieldName).build()
        }
        val paramNames = params.joinToString(separator = ",") { it.name }

        val bigIndexName = HumpUtil.lineToHump(ukIndex.indexName.split("uk_")[1], true)
        return MethodSpec.methodBuilder("getBy${bigIndexName}")
            .addModifiers(Modifier.PUBLIC)
            .addParameters(params)
            .addStatement(
                "\$T ${tableInfo.doInstanceName} = get${tableInfo.daoClassName}().getBy$bigIndexName($paramNames)",
                tableInfo.getDoClass()
            )
            .addStatement("return ${tableInfo.converterInstanceName}.to${tableInfo.entityClassName}(${tableInfo.doInstanceName})")
            .returns(tableInfo.getEntityClass())
            .build()
    }

    private fun genBatchGet(table: Table, tableInfo: TableInfo): MethodSpec {
        val listClass = ClassName.get("java.util", "List")
        val longClassName = ClassName.get("", "Long")
        val param = ParameterSpec.builder(ParameterizedTypeName.get(listClass, longClassName), "ids").build()
        val resultListClass: TypeName = ParameterizedTypeName.get(listClass, tableInfo.getEntityClass())
        val typedDoClass: TypeName = ParameterizedTypeName.get(listClass, tableInfo.getDoClass())

        val methodBuilder = MethodSpec.methodBuilder("batchGet")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(param)
            .returns(resultListClass)

        val supportBatchGet = super.isSupportBatchGet(table)
        if (supportBatchGet) {
            methodBuilder.beginControlFlow(
                "if (\$T.isEmpty(ids))",
                ClassName.get("org.springframework.util", "CollectionUtils")
            )
                .addStatement("return \$T.emptyList()", ClassName.get("java.util", "Collections"))
                .endControlFlow()
                .addStatement("\$T list = get${tableInfo.daoClassName}().batchGet(ids)", typedDoClass)
                .addStatement(
                    "return list.stream().map(it -> ${tableInfo.converterInstanceName}.to${tableInfo.entityClassName}(it)).collect(\$T.toList())",
                    ClassName.get("java.util.stream", "Collectors")
                )
        } else {
            methodBuilder.addStatement(
                "throw new \$T(\"this table type does not support batchGet\")",
                ClassName.get("", "UnsupportedOperationException")
            )
        }

        return methodBuilder.build()
    }

    private fun genRemove(tableInfo: TableInfo): MethodSpec {
        return MethodSpec.methodBuilder("remove")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(ParameterSpec.builder(TypeName.LONG.box(), "id").build())
            .addStatement("return get${tableInfo.daoClassName}().delete(id) == 1")
            .returns(TypeName.BOOLEAN)
            .build()
    }

    private fun genRemoveByBk(tableInfo: TableInfo): MethodSpec {
        return MethodSpec.methodBuilder("removeByBk")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(ParameterSpec.builder(tableInfo.getBkClass(), "bk").build())
            .addStatement("\$T ${tableInfo.entityInstanceName} = getByBk(bk)", tableInfo.getEntityClass())
            .beginControlFlow("if (${tableInfo.entityInstanceName} == null)")
            .addStatement("return true")
            .endControlFlow()
            .addStatement("return remove(${tableInfo.entityInstanceName}.getId())")
            .returns(TypeName.BOOLEAN)
            .build()
    }

    private fun genSave(table: Table, tableInfo: TableInfo): MethodSpec {
        val methodBuilder = MethodSpec.methodBuilder("save")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(ParameterSpec.builder(tableInfo.getEntityClass(), tableInfo.entityInstanceName).build())
            .returns(TypeName.BOOLEAN)

        val bkIndex = table.indexes?.firstOrNull { it.indexType == IndexType.UniqueBK }
        if (bkIndex == null) {
            methodBuilder.addStatement(
                "throw new \$T(\"this table type does not support getByBk\")",
                ClassName.get("", "UnsupportedOperationException")
            )
        } else {
            methodBuilder
                .addStatement(
                    "\$T ${tableInfo.doInstanceName} = ${tableInfo.converterInstanceName}.to${tableInfo.doClassName}(${tableInfo.entityInstanceName})",
                    tableInfo.getDoClass()
                )
                .beginControlFlow("if (${tableInfo.doInstanceName}.getId() != null)")
                .addStatement("return get${tableInfo.daoClassName}().update(${tableInfo.doInstanceName}) == 1")
                .endControlFlow()
                .addStatement(
                    "\$T pre = get${tableInfo.daoClassName}().getByBk(${tableInfo.entityInstanceName}.getBk())",
                    tableInfo.getDoClass()
                )
                .beginControlFlow("if (pre != null)")
                .addStatement("${tableInfo.entityInstanceName}.setId(pre.getId())")
                .addStatement("${tableInfo.doInstanceName}.setId(pre.getId())")
                .addStatement("${tableInfo.doInstanceName}.setVersion(pre.getVersion())")
                .addStatement("return get${tableInfo.daoClassName}().update(${tableInfo.doInstanceName}) == 1")
                .endControlFlow()
                .addStatement("boolean result = get${tableInfo.daoClassName}().insert(${tableInfo.doInstanceName}) == 1")
                .addStatement("${tableInfo.entityInstanceName}.setId(${tableInfo.doInstanceName}.getId())")
                .addStatement("return result")
        }

        return methodBuilder.build()
    }

    private fun genCreate(tableInfo: TableInfo): MethodSpec {
        val builder = MethodSpec.methodBuilder("create")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(ParameterSpec.builder(tableInfo.getEntityClass(), tableInfo.entityInstanceName).build())
            .returns(TypeName.BOOLEAN)
            .addStatement(
                "\$T ${tableInfo.doInstanceName} = ${tableInfo.converterInstanceName}.to${tableInfo.doClassName}(${tableInfo.entityInstanceName})",
                tableInfo.getDoClass()
            )
            .addStatement("boolean result = get${tableInfo.daoClassName}().insert(${tableInfo.doInstanceName}) == 1")
            .beginControlFlow("if (result)")
            .addStatement("${tableInfo.entityInstanceName}.setId(${tableInfo.doInstanceName}.getId())")
            .addStatement("${tableInfo.entityInstanceName}.setVersion(0)")
            .endControlFlow()
            .addStatement("return result")
        return builder.build()
    }

    private fun genUpdate(tableInfo: TableInfo): MethodSpec {
        val builder = MethodSpec.methodBuilder("update")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(ParameterSpec.builder(tableInfo.getEntityClass(), tableInfo.entityInstanceName).build())
            .returns(TypeName.BOOLEAN)
            .addStatement(
                "\$T ${tableInfo.doInstanceName} = ${tableInfo.converterInstanceName}.to${tableInfo.doClassName}(${tableInfo.entityInstanceName})",
                tableInfo.getDoClass()
            )
            .addStatement("return get${tableInfo.daoClassName}().update(${tableInfo.doInstanceName}) == 1")
        return builder.build()
    }

    private fun genPageNumQuery(table: Table, tableInfo: TableInfo): MethodSpec {
        val listClass = ClassName.get("java.util", "List")
        val resultListClass: TypeName = ParameterizedTypeName.get(listClass, tableInfo.getEntityClass())
        val queryClass = getQueryClass(table, tableInfo)
        val parameter = ParameterSpec.builder(queryClass, "query").build()

        if (!table.needGenPageNumQuery()) {
            return MethodSpec.methodBuilder("pageNumQuery")
                .addAnnotation(ClassName.get("", "Override"))
                .addModifiers(Modifier.PUBLIC)
                .addParameter(parameter)
                .addStatement(
                    "throw new \$T(\"does not support query\")",
                    ClassName.get("", "UnsupportedOperationException")
                )
                .returns(resultListClass)
                .build()
        }

        val typedDoClass: TypeName = ParameterizedTypeName.get(listClass, tableInfo.getDoClass())
        return MethodSpec.methodBuilder("pageNumQuery")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(parameter)
            .addStatement("\$T list = get${tableInfo.daoClassName}().pageNumQuery(query)", typedDoClass)
            .addStatement(
                "return list.stream().map(it -> ${tableInfo.converterInstanceName}.to${tableInfo.entityClassName}(it)).collect(\$T.toList())",
                ClassName.get("java.util.stream", "Collectors")
            )
            .returns(resultListClass)
            .build()
    }

    private fun genOffsetQuery(table: Table, tableInfo: TableInfo): MethodSpec? {
        val listClass = ClassName.get("java.util", "List")
        val resultListClass: TypeName = ParameterizedTypeName.get(listClass, tableInfo.getEntityClass())
        val queryClass = getOffsetQueryClass(table, tableInfo)
        val parameter = ParameterSpec.builder(queryClass, "query").build()

        if (!table.needGenOffsetQuery()) {
            return MethodSpec.methodBuilder("offsetQuery")
                .addAnnotation(ClassName.get("", "Override"))
                .addModifiers(Modifier.PUBLIC)
                .addParameter(parameter)
                .addStatement(
                    "throw new \$T(\"does not support query\")",
                    ClassName.get("", "UnsupportedOperationException")
                )
                .returns(resultListClass)
                .build()
        }

        val typedDoClass: TypeName = ParameterizedTypeName.get(listClass, tableInfo.getDoClass())
        return MethodSpec.methodBuilder("offsetQuery")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(parameter)
            .addStatement("\$T list = get${tableInfo.daoClassName}().offsetQuery(query)", typedDoClass)
            .addStatement(
                "return list.stream().map(it -> ${tableInfo.converterInstanceName}.to${tableInfo.entityClassName}(it)).collect(\$T.toList())",
                ClassName.get("java.util.stream", "Collectors")
            )
            .returns(resultListClass)
            .build()
    }

    private fun genCount(table: Table, tableInfo: TableInfo): MethodSpec {
        val queryClass = ClassName.get("com.hellocorp.automq.ddd", "Query")
        val parameter = ParameterSpec.builder(queryClass, "query").build()

        if (!table.needGenPageNumQuery()) {
            return MethodSpec.methodBuilder("count")
                .addAnnotation(ClassName.get("", "Override"))
                .addModifiers(Modifier.PUBLIC)
                .addParameter(parameter)
                .addStatement(
                    "throw new \$T(\"does not support count\")",
                    ClassName.get("", "UnsupportedOperationException")
                )
                .returns(TypeName.INT)
                .build()
        }

        return MethodSpec.methodBuilder("count")
            .addAnnotation(ClassName.get("", "Override"))
            .addModifiers(Modifier.PUBLIC)
            .addParameter(parameter)
            .addStatement("return get${tableInfo.daoClassName}().count(query)")
            .returns(TypeName.INT)
            .build()
    }
}
