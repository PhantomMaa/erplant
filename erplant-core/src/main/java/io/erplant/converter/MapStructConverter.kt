package io.erplant.converter

import com.squareup.javapoet.*
import io.erplant.*
import io.erplant.utils.HumpUtil
import javax.lang.model.element.Modifier

class MapStructConverter(packageName: String, val render: BaseRender, tableConfigMap: Map<String, TableConfig>) :
    JavaPoetConverter(packageName, tableConfigMap) {

    override fun getSupportType(): SupportType {
        return SupportType.Converter
    }

    override fun convertTable(databaseName: String, table: Table): FileContent {
        val fileName = super.getOutFileName(table.doName)
        val tableInfo = TableInfo(packageName, databaseName, table, render)
        val methods = listOf(
            genDoToEntityMethod(table, tableInfo),
            genEntityToDoMethod(table, tableInfo)
        )

        val fullPackageName = tableInfo.getConverterClass().packageName()
        val className = tableInfo.converterClassName
        val javaDocAuthor = "auto generated by erplant."

        val mapperAnnotation = AnnotationSpec.builder(ClassName.get("org.mapstruct", "Mapper"))
            .addMember("componentModel", "\$S", "spring")
            .build()
        val typeSpec = TypeSpec.interfaceBuilder(className)
            .addJavadoc(javaDocAuthor)
            .addAnnotation(mapperAnnotation)
            .addModifiers(Modifier.PUBLIC)
            .addMethods(methods)
            .build()
        val javaFile = JavaFile.builder(fullPackageName, typeSpec).indent(StrConstant.INDENT).build()
        return FileContent(fileName, javaFile.toString())
    }

    private fun genDoToEntityMethod(table: Table, tableInfo: TableInfo): MethodSpec {
        val mappingAnnotations = genMappingAnnotationsForEntity(table)
        val param = ParameterSpec.builder(tableInfo.getDoClass(), tableInfo.doInstanceName).build()
        return MethodSpec.methodBuilder("to${tableInfo.entityClassName}")
            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
            .addAnnotations(mappingAnnotations)
            .addParameter(param)
            .returns(tableInfo.getEntityClass())
            .build()
    }


    private fun genEntityToDoMethod(table: Table, tableInfo: TableInfo): MethodSpec {
        val mappingAnnotations = genMappingAnnotationsForDo(table)
        val param = ParameterSpec.builder(tableInfo.getEntityClass(), tableInfo.entityInstanceName).build()
        return MethodSpec.methodBuilder("to${tableInfo.doClassName}")
            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
            .addAnnotations(mappingAnnotations)
            .addParameter(param)
            .returns(tableInfo.getDoClass())
            .build()
    }

    private fun genMappingAnnotationsForEntity(table: Table): List<AnnotationSpec> {
        if (table.extensions == null) {
            return emptyList()
        }

        return table.extensions.map {
            val extensionVOName = HumpUtil.lineToHump(it.columnName, false) + "VO"
            AnnotationSpec.builder(ClassName.get("org.mapstruct", "Mapping"))
                .addMember("source", "\$S", "${extensionVOName}.${it.fieldName}")
                .addMember("target", "\$S", it.fieldName)
                .build()
        }
    }

    private fun genMappingAnnotationsForDo(table: Table): List<AnnotationSpec> {
        if (table.extensions == null) {
            return emptyList()
        }

        return table.extensions.map {
            val extensionVOName = HumpUtil.lineToHump(it.columnName, false) + "VO"
            AnnotationSpec.builder(ClassName.get("org.mapstruct", "Mapping"))
                .addMember("source", "\$S", it.fieldName)
                .addMember("target", "\$S", "${extensionVOName}.${it.fieldName}")
                .build()
        }
    }
}
